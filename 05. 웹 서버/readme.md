# 5. 웹 서버

## 5.1 다채로운 웹 서버
- 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.
- 웹 서버는 **_웹 서버 소프트웨어_** 와 **_웹 페이지를 제공하는데 특화된 장비_** 둘 다 의미한다.
- 다양한 웹 서버가 있지만, 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 돌려준다.

![image](https://user-images.githubusercontent.com/87873821/223133176-2d5cd4c4-0da1-4a56-84c9-008a9afd80f2.png)

- ### **5.1.1 웹 서버 구현**
  - 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.
  - 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공한다.
  - 다목적 소프트웨어 및 임베디드 웹 서버로 나눌 수 있다.

- ### **5.1.2 다목적 소프트웨어 웹 서버**
  - 다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.
  - 웹 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작한다. 
![image](https://user-images.githubusercontent.com/87873821/223134884-d520c450-da16-46e4-aa06-bb417fbece7f.png)

- ### **5.1.3 임베디드 웹 서버**
  - 임베디드 웹 서버는 프린터나 가전제품 등에 들어가며, 간편한 웹 브라우저 인터페이스로 관리할 수 있게 되어있다.

## 5.2 간단한 펄 웹 서버
- 생략

## 5.3 진짜 웹 서버가 하는 일
- 그림 정리할 것!

## 5.4 단계 1: 클라이언트 커넥션 수락
- ### **5.4.1 새 커넥션 다루기**
  - 클라이언트가 웹 서버에 TCP 커넥션을 요청하면 웹 서버는 커넥션을 맺고 IP 주소를 추출하여 어떤 클라이언트가 있는지 확인한다.
  - 새 커넥션 이후, 서버는 새 커넥션을 목록에 추가하고 오가는 데이터를 지켜볼 준비를 한다.
  - 웹 서버는 클라이언트의 IP 주소가 위험하다고 판단하면 커넥션을 닫을 수 있다.

- ### **5.4.2 클라이언트 호스트 명 식별**
  - 대부분의 웹 서버는 **_역방향 DNS(reverse DNS)_**를 사용하여 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 변환한다.
  - 클라이언트의 호스트 명은 **_접근 제어 및 로깅_**을 위해 사용할 수 있다.
  - **_호스트 명 룩업_**은 웹 트랜잭션을 느려지게 한다.
  - **_호스트 명 분석_**은 대부분의 웹 서버가 끄거나 특정 콘텐츠에 대해서만 켜놓는다.

- ### **5.4.3 ident를 통해 클라이언트 사용자 알아내기**
  - 몇몇 웹 서버는 IETF 프로토콜을 지원한다. ident 프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화 했는지 찾아내준다.
  - 웹 서버 로깅에서 유용하며, 일반 로그 포맷의 두번째 필드는 각 HTTP 요청의 ident 사용자 이름을 담고있다. (RFC 1413이 대체함.)
  - 클라이언트가 ident 프로토콜을 지원한다면 클라이언트는 ident 결과를 위해 TCP 포트 113번을 Listen 한다.
  - 공공 인터넷에서는 여러 단점에 의해 잘 동작하지 않는다.
  - 그림 정리할 것!

## 5.5 단계 2: 요청 메시지 수신
  - 커넥션에 데이터가 도착하면 웹 서버는 커넥션에서 그 데이터를 읽고 파싱하여 요청 메시지를 구성한다.
  - 요청 줄을 파싱하여 메서드, URI, HTTP 버전을 찾는다. 이후 헤더를 찾으며 각 헤더는 CRLF로 끝난다.
  - 엔티티가 있을 경우 읽어들이며, 길이는 Content-Length 헤더로 정의된다.

![image](https://user-images.githubusercontent.com/87873821/223754223-c06e3431-d8e7-49bc-b43f-86b3d4388fd7.png)

- ### **5.5.1 메시지의 내부 표현**
  - 특정 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.
- ### **5.5.2 커넥션 입력 / 출력 처리 아키텍처**
  - 고성능 웹 서버는 수천개의 커넥션을 동시에 열 수 있도록 지원한다.
  - **_단일 스레드 웹 서버_**
    - 한번에 하나씩 요청을 처리하며, 성능이 매우 떨어저 간단한 점검 도구에서만 사용한다.
  - **_멀티 스레드 웹 서버_**
    - 여러 요청을 동시에 처리하기 위해 여러개의 프로세스 혹은 고효율 스레드를 할당한다.

## 5.6 단계 3: 요청 처리
  - 웹 서버가 요청을 받으면 서버는 요청 메시지에서 메서드, 리소스, 헤더, 본문을 얻어 처리한다.

## 5.7 단계 4: 리소스의 매핑과 접근
  - 웹 서버는 리소스를 제공한다. 웹 서버가 클라이언트에 리소스를 전달하려면 요청 메시지의 URI에 대응하는 콘텐츠 혹은 생성기를 찾아 전달해야 한다.

- ### **5.7.1 Docoroot**
  - 리소스 매핑의 가장 단순한 형태는 요청 URI를 웹 서버 파일시스템 내부 파일 이름으로 사용하는 것.
  - 일반적으로 웹 서버 파일 시스템의 특정 폴더를 웹 콘텐츠를 위해 예약해놓으며, 문서 루트 혹은 docroot 로 불린다.

![image](https://user-images.githubusercontent.com/87873821/223759121-8c404de0-3d42-480d-bb51-95f5d8da86e7.png)

- ### **5.7.1 가상 호스팅 Docoroot**
  - 가상 호스팅 웹 서버는 각각 분리된 문서 루트를 부여하여 하나의 웹 서버에서 여러개의 웹 사이트를 호스팅한다.
  - 웹 서버는 URI 혹은 Host 헤더에서 얻은 주소, 호스트 명을 이용하여 올바른 문서 루트를 식별한다.

![image](https://user-images.githubusercontent.com/87873821/223765097-929e1c06-c573-460f-a8c9-82be97bc2021.png)

- ### **5.7.1 사용자 홈 디렉토리 Docoroot**
