# 5. 웹 서버

## 5.1 다채로운 웹 서버

> - 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.  
> - 웹 서버는 **_웹 서버 소프트웨어_** 와 **_웹 페이지를 제공하는데 특화된 장비_** 둘 다 의미한다.  
> - 다양한 웹 서버가 있지만, 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 돌려준다.

![image](https://user-images.githubusercontent.com/87873821/223133176-2d5cd4c4-0da1-4a56-84c9-008a9afd80f2.png)

- ### **5.1.1 웹 서버 구현**
  > - 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.
  > - 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공한다.
  > - 다목적 소프트웨어 및 임베디드 웹 서버로 나눌 수 있다.

- ### **5.1.2 다목적 소프트웨어 웹 서버**
  > - 다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.
  > - 웹 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작한다. 
![image](https://user-images.githubusercontent.com/87873821/223134884-d520c450-da16-46e4-aa06-bb417fbece7f.png)

- ### **5.1.3 임베디드 웹 서버**
  > - 임베디드 웹 서버는 프린터나 가전제품 등에 들어가며, 간편한 웹 브라우저 인터페이스로 관리할 수 있게 되어있다.
---
## 5.2 간단한 펄 웹 서버
- 생략
---
## 5.3 진짜 웹 서버가 하는 일
1. 커넥션 생성
2. 요청 메시지 수신
3. 요청 메시지 처리
4. 리소스 접근
5. 응답 메시지 생성
6. 응답 메시지 전송
7. 로그 작성
---
## 5.4 단계 1: 클라이언트 커넥션 수락
- ### **5.4.1 새 커넥션 다루기**
  > - 클라이언트가 웹 서버에 TCP 커넥션을 요청하면 웹 서버는 커넥션을 맺고 IP 주소를 추출하여 어떤 클라이언트가 있는지 확인한다.
  > - 새 커넥션 이후, 서버는 새 커넥션을 목록에 추가하고 오가는 데이터를 지켜볼 준비를 한다.
  > - 웹 서버는 클라이언트의 IP 주소가 위험하다고 판단하면 커넥션을 닫을 수 있다.

- ### **5.4.2 클라이언트 호스트 명 식별**
  > - 대부분의 웹 서버는 **역방향 DNS(reverse DNS)**를 사용하여 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 변환한다.
  > - 클라이언트의 호스트 명은 **접근 제어 및 로깅**을 위해 사용할 수 있다.
  > - **호스트 명 룩업**은 웹 트랜잭션을 느려지게 한다.
  > - **호스트 명 분석**은 대부분의 웹 서버가 끄거나 특정 콘텐츠에 대해서만 켜놓는다.

- ### **5.4.3 ident를 통해 클라이언트 사용자 알아내기**
  > - 몇몇 웹 서버는 IETF 프로토콜을 지원한다. ident 프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화 했는지 찾아내준다.
  > - 웹 서버 로깅에서 유용하며, 일반 로그 포맷의 두번째 필드는 각 HTTP 요청의 ident 사용자 이름을 담고있다. (RFC 1413이 대체함.)
  > - 클라이언트가 ident 프로토콜을 지원한다면 클라이언트는 ident 결과를 위해 TCP 포트 113번을 Listen 한다.
  > - 공공 인터넷에서는 여러 단점에 의해 잘 동작하지 않는다.
  > - 그림 정리할 것!
---
## 5.5 단계 2: 요청 메시지 수신
  > - 커넥션에 데이터가 도착하면 웹 서버는 커넥션에서 그 데이터를 읽고 파싱하여 요청 메시지를 구성한다.
  > - 요청 줄을 파싱하여 메서드, URI, HTTP 버전을 찾는다. 이후 헤더를 찾으며 각 헤더는 CRLF로 끝난다.
  > - 엔티티가 있을 경우 읽어들이며, 길이는 Content-Length 헤더로 정의된다.
  > ![image](https://user-images.githubusercontent.com/87873821/223754223-c06e3431-d8e7-49bc-b43f-86b3d4388fd7.png)

- ### **5.5.1 메시지의 내부 표현**
  > 특정 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.
- ### **5.5.2 커넥션 입력 / 출력 처리 아키텍처**
  > 고성능 웹 서버는 수천개의 커넥션을 동시에 열 수 있도록 지원한다.
  - **_단일 스레드 웹 서버_**
    > 한번에 하나씩 요청을 처리하며, 성능이 매우 떨어저 간단한 점검 도구에서만 사용한다.
  - **_멀티 스레드 웹 서버_**
    > 여러 요청을 동시에 처리하기 위해 여러개의 프로세스 혹은 고효율 스레드를 할당한다.
---
## 5.6 단계 3: 요청 처리
  > 웹 서버가 요청을 받으면 서버는 요청 메시지에서 메서드, 리소스, 헤더, 본문을 얻어 처리한다.
---
## 5.7 단계 4: 리소스의 매핑과 접근
  > 웹 서버는 리소스를 제공한다. 웹 서버가 클라이언트에 리소스를 전달하려면 요청 메시지의 URI에 대응하는 콘텐츠 혹은 생성기를 찾아 전달해야 한다.

- ### **5.7.1 Docoroot**
  > - 리소스 매핑의 가장 단순한 형태는 요청 URI를 웹 서버 파일시스템 내부 파일 이름으로 사용하는 것.
  > - 일반적으로 웹 서버 파일 시스템의 특정 폴더를 웹 콘텐츠를 위해 예약해놓으며, 문서 루트 혹은 docroot 로 불린다.
  > ![image](https://user-images.githubusercontent.com/87873821/223759121-8c404de0-3d42-480d-bb51-95f5d8da86e7.png)

- ### **5.7.1 가상 호스팅 Docoroot**
  > - 가상 호스팅 웹 서버는 각각 분리된 문서 루트를 부여하여 하나의 웹 서버에서 여러개의 웹 사이트를 호스팅한다.
  > - 웹 서버는 URI 혹은 Host 헤더에서 얻은 주소, 호스트 명을 이용하여 올바른 문서 루트를 식별한다.
  > - 하나의 서버가 어러개의 도메인을 가지고, 각 도메인마다 다른 서비스를 이용하고 싶을 때 사용
![image](https://user-images.githubusercontent.com/87873821/223765097-929e1c06-c573-460f-a8c9-82be97bc2021.png)

- ### **5.7.1 사용자 홈 디렉토리 Docoroot**
  > - /~ 다음에 사용자 이름이 오는것으로 시작하는 URI는 사용자의 개인 문서 루트를 가리킴.
  > - 개인 docroot는 주로 사용자 홈 디렉토리 내부 public_html 이름의 디렉토리를 가르킨다.
- ### **5.7.2 디렉터리 목록**
  > 웹 서버가 파일이 아닌 폴더를 가르키는 요청을 받을 경우 다음과 같은 행동이 가능하다.
    1. 에러 반환
    2. 설정한 색인 파일 반환
    3. 폴더 내부 내용을 담은 HTML 파일 반환

- ### **5.7.3 동적 콘텐츠 리소스 매핑**
  > - URI를 동적 리소스에 매피하여 요청에 맞게 콘텐츠를 가져올 수 있다.
  > - 웹 애플리케이션 서버의 경우 웹 서버를 복잡한 백엔드 애플리케이션과 연결한다.
  > - 자바 서블릿, JSP와 같이 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트 등이 있다.

- ### **5.7.4 서버사이드 인클루드**
  ![image](https://user-images.githubusercontent.com/87873821/224109585-73647e37-1eab-4e3d-93f9-ab9db1410a1d.png)

- ### **5.7.5 접근 제어**
  > 각각의 리소스에 접근 제어를 할당하여 IP를 기반으로 권한 확인 및 추가 비밀번호등을 요청할 수 있다.
---
## 5.8 단계 5: 응답 만들기
  > 서버가 리소스를 식별한 이후, 요청 메서드의 행동을 수행한 뒤 응답 메시지를 반환한다.  
  응답 메시지는 상태 코드, 응답 헤더, 엔티티로 이루어져 있다.
- ### **5.8.1 응답 엔티티**
  > 응답 메시지는 주로 다음을 포함한다.
  1. 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
  2. 응답 본문의 길이를 서술하는 Content-Length 헤더
  3. 응답 본문
- ### **5.8.2 MIME 타입 결정**
  > 웹 서버는 응답 본문의 MIME 타입을 결정해야 하며, 아래 방식들로 가능하다.
  1. mime.types
      - 웹 서버는 MIME 타입을 나타내기 위해 파일 이름의 확장자를 사용할 수 있다.
  2. 매직 타이핑
      - 아파치 웹 서버는 파일의 내용을 검사해 잘 알려진 패턴을 파악하여 매직 테이블과 비교해 MIME 타입을 찾아낸다.
  3. 유형 명시
      - 내부 파일과 상관 없이 특정 MIME 타입을 갖도록 웹 서버를 설정할 수 있다.
  4. 유형 협상
      - 어떤 웹 서버는 한 리소스가 여러개의 문서 형식에 속하도록 설정 가능하며, 특정 파일이 특정 MIME 타입을 가지게 설정할 수 있다.
- ### **5.8.3 리다이렉션**
  > 웹 서버는 종종 성공 메시지 대신 리다이렉션 응답을 반환한다.  
    웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉션 할 수 있으며  
    리다이렉션의 응답 코드는 3XX 상태 코드로 지칭된다.
  - 영구히 리소스가 옮겨진 경우
    - 리소스에 새 URI가 부여되어 옮겨지거나 이름이 변경되었을 수 있다.
  - 임시로 리소스가 옮겨진 경우
    - 임시로 옮겨진 경우 서버는 클라이언트를 새로운 URI 로 리다이렉트 시킬 것이다.
  - URL 증강
    - 서버는 종종 문맥 정보를 포함시키기 위해 사용자를 새 URL로 리다이렉트 하며 클라이언트는 완전한 URL을 다시 보내게 된다.
  - 부하 균형
    - 과부하가 된 서버가 요청을 받으면 서버는 클라이언트를 다른 서버로 리다이렉트 할 수 있다.
  - 친밀한 다른 서버
    - 클라이언트의 정보를 가진 다른 서버로 리다이렉트 시킨다.
  - 디렉토리 이름 정규화
    - 클라이언트가 URI끝에 "/"를 빠트린다면 웹 서버는 상대경로를 동작시키기 위해 추가 후 리다이렉트한다.
---
## 5.9 단계 6: 응답 보내기
  > 웹 서버는 요청을 받을때와 유사하게 요청을 보낼 때에도 커넥션을 관리한다.  
  사바는 커넥션 상태를 추적해야 하며, 비지속 커넥션의 경우 메시지 전송 이후 커넥션을 닫는다.  
  지속 커넥션이라면 주의가 필요한 경우 계속해서 열린 상태를 유지할 것이다.
---
## 5.10 로깅
  > 트랜잭션이 끝나면 서버는 트랜잭션이 어떻게 수행되었는지 로그를 기록한다.