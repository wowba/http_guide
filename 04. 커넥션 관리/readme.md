# 4. 커넥션 관리
- HTTP 어플리케이션을 개발한다면 HTTP 커넥션과 HTTP 메시지에 대한 흐름을 잘 이해해야 한다.

## 4.1 TCP 커넥션
- 모든 HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP 를 통해 이루어진다.
- TCP/IP 커넥션을 맺으면 클라이언트와 서버간 주고받는 메시지들은 손실되지 않으며 안전하게 전달된다.

```
TCP 커넥션 진행 순서

0. 브라우저에 아래 URL 입력
http://hello.com:80/index.html

1. 호스트 명 추출
www.hello.com

2. 호스트 명에 대한 IP 주소 추출
123.45.67.8

3. 포트번호 추출
80

4. 브라우저가 123.45.67.8 의 80번 포트에 TCP 커넥션 생성

브라우저 ---TCP--- 서버

5. 브라우저가 서버에 GET 요청 전달

브라우저 ---GET---> 서버

6. 브라우저가 서버에서 전달한 응답 메시지 확인

브라우저 <---Response--- 서버

7. 브라우저가 커넥션 종료

브라우저 ---X--- 서버
```

- ### **4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP**
  - HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과하다.
  - TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 전달된다.
  ```
  클라이언트 --- ...lmth.xdeni/ TEG ---> 서버
  ``` 
- ### **4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.**
  - TCP는 IP 패킷이라는 작은 조각을 통해 데이터를 전송한다.
  - HTTP는 프로토콜 스택에서 최상위 계층이다.

![image](https://user-images.githubusercontent.com/87873821/221582603-8de5687c-cb46-48a8-882e-f5659a72d702.png)
  - HTTP가 메시지를 전송하고자 할 경우 현재 연결되어 있는 TCP 커넥션을 통해서 내용을 순서대로 전달한다.
  - TCP는 세그먼트 라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라는 봉투에 담아 전달한다.
  - 각 TCP 세그먼트는 하나의 IP에서 다른 IP주소로 패킷에 담겨 전달되며, 다음을 포함한다.
    - IP 패킷 헤더
    - TCP 세그먼트 헤더
    - TCP 데이터 조각
  
- ### **4.1.3 TCP 커넥션 유지하기**
  - 컴퓨터는 항상 TCP 커넥션을 여러개 가지고 있으며, 포트 번호를 통해 여러개의 커넥션을 유지한다.
  ```
  TCP 커넥션 값

  <발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
  ```
  - 이 네가지 값을 통해 유일한 커넥션을 생성하며, 서로 다른 TCP 커넥션은 구성요소의 값이 모두 같을 수 없다.

- ### **4.1.4 TCP 소켓 프로그래밍**
  - ..?

## 4.2 TCP의 성능에 대한 고려
- HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.
- TCP 성능의 특성을 이해하여 HTTP 커넥션 최적화를 이해한다.
- ### **4.2.1 HTTP 트랜잭션 지연**
  - 트랜잭션을 처리하는 시간은 TCP 커넥션 설정, 요청 및 응답 시간에 비하면 짧다.
  - 즉, 대부분의 지연은 TCP 네트워크 지연에 의해 발생한다.
  ```
      서버 ----- | ------ | ---- | --- | --- | ---- |
                    ↗↘       ↗          ↘
                  ↗    ↘   ↗              ↘
  클라이언트 ----- | ------ | ---- | --- | --- | ---- | 
           DNS      연결     요청   처리    응답   종료
  ```
  1. DNS 서비스에서 IP를 확인하는데 소요되는 시간
  2. TCP 커넥션을 생성하는데 소요되는 시간
  3. 요청, 응답 메세지 전송 소요 시간
  - 이렇게 다양한 요소에 의해 TCP 네트워크 지연이 발생하게 된다.

- ### **4.2.2 성능 관련 중요 요소**
  - TCP 커넥션의 핸드셰이크 설정
  - TCP 의 느린 시작
  - 네이글 알고리즘
  - 확인응답 지연 알고리즘
  - TIME_WAIT 지연 및 포트고갈

## 4.3 HTTP 커넥션 관리
- ### **4.3.1 Connection 헤더**
  - HTTP 메시지는 모든 클라이언트와 서버 사이 모든 중개 서버들을 거친다. 이 경우 두 애플리케이션이 맺는 커넥션에 적용되는 옵션을 지정해야 한다.
  - Connection 헤더 필드는 커넥션 토큰을 쉼표로 가지고 있으며, 각 값은 다른 커넥션에 전달되지 않는다.
  - Connection 헤더 필드는 다음 세가지 종류의 토큰이 전달될 수 있다.
    - HTTP 헤더 필드 명은, 이 커넥션에만 해당되는 헤더들을 나열한다.
    - 임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미한다.
    - close 값은, 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.
- ### **4.3.2 순차적인 트랜잭션 처리에 의한 지연**
  - 트랜잭션 별로 새로운 커넥션을 생성해야 한다면 물리적으로 시간이 많이 소요될 것이다.
  - 순차적으로 로드할 경우 특정 브라우저는 모든 객체를 내려받기 전까지 빈화면을 보여준다.  
  ```
           트랜잭션1      트랜잭션2       트랜잭션3       트랜잭션4
      서버 --------- | ---------- | ----------- | ---------- | ------
               ↗↘           ↗↘            ↗↘            ↗↘ 
              ↗  ↘         ↗  ↘          ↗  ↘          ↗  ↘    
  클라이언트 ---|----- | ---|------ | ---|------- | ---|------ | ------  
         (연결)커넥션 1 (연결)커넥션 2  (연결)커넥션 3   (연결)커넥션 4     
  ```
## 4.4 병렬 커넥션
- HTTP는 클라이언트가 여러 개의 TCP 커넥션을 맺음으로써 여러개의 트랜잭션을 병렬로 처리할 수 있게 한다.
![image](https://user-images.githubusercontent.com/87873821/222198009-6b235bd7-011c-4bd4-80a1-b3319fa04f33.png)

- ### **4.4.1 병렬 커넥션은 페이지를 빠르게 내려받는다**
  - 각 커넥션의 지연시간을 겹쳐 총 지연시간을 줄이고, 나머지 객체를 내려받는데 나머지 대역폭을 사용할 수 있다.
  - 각 커넥션 사이에에는 소프트웨어와 관련된 지연이 아주 짧게 발생한다.
  ```
          트랜잭션1   트랜잭션 2, 3, 4 (병렬 커넥션)
      서버 --------| -------------
              ↗↘      
             ↗  ↘         
  클라이언트 ------- | -------------
           커넥션 1    커넥션 2
                       커넥션 3
                        커넥션 4   
  ```
- ### **4.4.2 병렬 커넥션이 더 빠르지는 않다.**
  - 클라이언트의 대역폭이 좁을 때는 대부분 시간을 데이터를 전송하는데만 사용한다.
  - 여러 객체를 병렬로 내려받는 경우, 대역폭 내에서 객체를 전송받는것은 느려 성능상의 장점은 없다.
  - 다수의 커넥션은 메모리를 많이 소모하며 이는 서버의 성능을 크게 떨어트린다. 실제로 브라우저는 적은 수의 병렬 커넥션만 허용한다.

- ### **4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있다.**
  - 병렬 커넥션이 실제로 페이지를 더 빠르게 내려받는 것은 아니지만, 사용자는 빠르게 느낄 수 있다.

## 4.5 지속 커넥션 
- 웹 클라이언트는 사이트에 여러개의 커넥션을 맺으며, 다른 정보를 불르오기 위해 다시 요청하는데 이를 사이트 지역성 이라고 부른다.
- HTTP 1.1을 지원하는 기기는 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 사용할 수 있다. 이런 커넥션을 지속 커넥션이라고 부른다.
- 지속 커넥션을 사용함으로 커넥션을 연결하는데 소요되는 시간을 절약할 수 있다.

- ### **4.5.1 지속 커넥션 vs 병렬 커넥션**
  - 병렬 커넥션은 다음과 같은 단점들이 존재한다.
    - 트랜잭션마다 새로 연결하기 때문에 시간 / 대역폭 소모
    - 각각의 새로운 커넥션은 TCP 느린시작 때문에 성능이 떨어짐
    - 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.
  - 지속 커넥션은 이러한 시간적인 문제 및 커넥션의 수를 줄여준다.
  - 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적이며 현대 웹 어플리케이션은 적은 수의 병렬 커넥션을 맺고 그걸 유지한다.

- ### **4.5.2 HTTP/1.0의 Keep-Alive 커넥션**
  - Keep Alive 커넥션은 커넥션을 맺고 끊는 데 필요한 작업이 없어 시간이 단축되었다.
  ```
  연속 커넥션
           트랜잭션1      트랜잭션2       트랜잭션3       트랜잭션4
      서버 --------- | ---------- | ----------- | ---------- | ------
               ↗↘           ↗↘            ↗↘            ↗↘ 
              ↗  ↘         ↗  ↘          ↗  ↘          ↗  ↘    
  클라이언트 ---|----- | ---|------ | ---|------- | ---|------ | ------  
         (연결)커넥션 1 (연결)커넥션 2  (연결)커넥션 3   (연결)커넥션 4     
  
  지속 커넥션
         트랜잭션1   2      3      4
      서버 ---- | ---- | ---- | ---- | ------
           ↗↘     ↗↘     ↗↘     ↗↘ 
          ↗  ↘   ↗  ↘   ↗  ↘   ↗  ↘    
  클라이언트 ---- | ---- | ---- | ---- | ------  
  ```
- ### **4.5.3 Keep-Alive 동작**
  - Keep Alive는 사용하지 않게 되어 HTTP/1.1 명세에서 빠졌지만 아직 많이 사용되고 있어 처리할 수 있어야 한다.
  - HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해 요청에 Connection:Keep-Alive 헤더를 포함한다.
  - 이 요청을 받은 경우, 서버가 응답 메세지에 같은 헤더를 포함하지 않으면 클라이언트는 서버가 커넥션을 끊을 것이라 추정한다.
  - Keep Alive 헤더는 단순히 클라이언트의 요청이며, 서버는 이를 무시할 수 있다.
![image](https://user-images.githubusercontent.com/87873821/222211445-36501b0a-6851-4b32-99e2-b0b50e7ce809.png)

- ### **4.5.4 Keep-Alive 옵션**
  - timeout 파라미터는 Keep-Alive 응답 헤더를 통해 보낸다. 커넥션이 얼마나 유지될 것인지 설정한다.
  - max 파라미터는 Keep-Alive 응답 헤더를 통해 보낸다. 최대 몇개의 트랜잭션을 처리하는지를 의미한다.
  - Keep-Alive 헤더는 진단 혹은 디버깅을 주 목적으로 하는 임의 속성을 지원하기도 하며, 각 파리미터가 동작한다는 보장은 없다.

- ### **4.5.5 Keep-Alive 커넥션 제한과 규칙**
  - Keep Alive 를 사용하기 위해선 Connection: Keep-Alive 요청 헤더를 보내야 한다.
  - 커넥션을 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해야 한다.
  - 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는걸 보고 서버가 커넥션을 끊을 것이라 추측한다.
  - 커넥션이 끊기기 전, 엔티티 본문의 길이를 알아야 커넥션을 유지할 수 있다.
  - 프락시, 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 한다. HTTP 메시지를 전달하거나 캐싱하기 전 Connection 헤더에 명시된 모든 필드와 헤더를 제거해야 한다.
  - Keep-Alive 커넥션은 Connection 헤더를 인식 못하는 프락시 서버와는 맺어지면 안된다.
  - HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필드는 무시해야 한다.
  - 클라이언트는 응답 전체를 받기 전 커넥션이 끊어질 경우 요청을 다시 보낼 수 있게 준비되어 있어야 한다.

- ### **4.5.6 Keep-Alive 와 멍청한 프락시**
  1. 웹 클라리언트 요청에 Connection: Keep-Alive가 있다면 TCP 연결을 계속 유지한다.
  2. 하지만 프락시가 Connection 헤더를 이해하지 못하고 보낸다면, Connection 헤더는 홉 별 헤더이기 때문에 문제가 발생한다.
  3. 프락시는 Keep-Alive가 무엇인지 이해하지 못한채 클라이언트에 데이터를 전달하고 커넥션을 끊기를 기다리지만 서버는 커넥션을 요청한 것으로 이해하여  
  연결을 끊지 않는다.
  4. 하지만 클라이언트는 Keep-Alive 헤더를 받았기에 프락시가 동의한 것으로 이해하여 여청을 보내고, 프락시는 같은 커넥션에서 요청이 또 오는 경우는 예상하지  
  못하므로 프락시는 해당 요청을 무시하고 브라우저는 응답을 받지 못한다.
  5. 이러한 잘못된 통신 때문에 브라우저는 자신 혹은 서버가 타임아웃 에러가 날 때까지 기다린다.

  - 결국 이런 종류의 오류를 피하기 위해 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안된다.

- ### **4.5.7 Proxy-Connection 살펴보기**
  - 멍청한 프락시는 Connection 헤더와 같은 홉 별 헤더를 무조건 전달하며, 이를 해결하기 위해 Proxy-Connection 확장 헤더가 나왔다.
  - Proxy-Connection 이 전달되더라도 클라이언트와 프락시, 프락시와 서버간 Keep-Alive 커넥션이 맺어지지 않는다.
  - 영리한 프락시는 Proxy-Connection 헤더가 Keep-Alive를 요청하는 것을 인식하여 자체적으로 Connection: Keep-Alive 헤더를 전달한다.

- ### **4.5.8 HTTP/1.1의 지속 커넥션**
  - HTTP/1.1 에서는 Keep-Alive 를 지원하지 않지만 설계가 더 개선된 커넥션을 지원한다.
  - 기본적으로 모든 커넥션을 지속 커넥션으로 취급, 트랜잭션을 끊기 위해선 Connection: close 헤더를 명시해야 한다.

- ### **4.5.9 지속 커넥션의 제한과 규칙**
  - ...

## 4.6 파이프라인 커넥션
  - HTTP/1.1 은 지속 커넥션을 통해 요청을 파이프라이닝 할 수 있다.
  - 여러개의 요청은 응답이 도착하기 전 큐에 쌓이며, 첫 요청이 전달 된 이후 다음 요청들이 순차적으로 전달된다. 이는 대기시간을 크게 줄여준다.
  - HTTP 클라이언트는 지속 커넥션인지 확인되기 전에는 파이프라인을 이어선 안된다.
  - 응답은 요청 순서와 동일하게 와야 한다.
  - HTTP 클라이언트는 커넥션이 언제 끊어지더라도 완료되지 않은 요청이 있으면 언제든지 다시 요청을 보낼 준비가 되어야 한다.
  - 비멱등 요청을 재차 보내선 안된다.
  ```
  파이프라인 커넥션

      서버 ---------------
              ↗↗↗↗↘↘↘↘      
             ↗↗↗↗  ↘↘↘↘         
  클라이언트 ---------------
           커넥션 1    
            커넥션 2
              커넥션 3
                커넥션 4   
  ```

## 4.7 커넥션 끊기에 대한 미스터리
  - 커넥션 관리에는 명확한 기준이 없고 여러가지 케이스가 존재한다.
- ### **4.7.1 마음대로 커넥션 끊기**
  - 어떠한 HTTP 클라이언트, 서버, 혹은 프락시든 언제든지 TCP 전송 커넥션을 끊을 수 있다.
- ### **4.7.2 Content-Length 와 Truncation**
  - 각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다.
  - 커넥션이 끊어진 이후 실제 전달된 엔티티의 길이와 Content-Length의 값이 일치하지 않거나 값이 없다면  
  수신자는 정확한 데이터의 길이를 서버에 요청해야 한다.
- ### **4.7.3 커넥션 끊기의 허용**
  - 커넥션은 에러가 없어도 끊을 수 있다.
  - 트랜잭션 수행 중 끊어져도, 클라이언트는 트랜잭션을 다시 요청해도 문제가 없다면 커넥션을 다시 맺고 전송을 시도해야 한다.  
  이 경우 서버는 아직 처리되지 않은 요청들을 남겨둔 채 커넥션을 끊을 수 있다.
  - 응답이 오기 전에 커넥션이 끊어진 경우, 요청이 중복 될 수 있기 때문에 조심해야 한다. 이러한 비멱등 요청의 경우 파이프라인을 이용하면 안된다.
- ### **4.7.4 우아한 커넥션 끊기**
  - ...